
define endian=big;

# Codespace, 64k ROM
define space CODE type=ram_space size=2 default;

# Registers of the processor are memory mapped - thus they cannot be
#  modeled using the traditional SLEIGH model.
#
# The only exception is PC, which cannot be aliased by memory
define space register type=register_space size=1;

    define register offset=0x0 size=2 [ PC ];

# Internal memory, 512 RAM - addressing is weird
#
# The entire space can be indirectly adressed, however direct adresses
#  within 0x80-0xFF actually index into the SFR space, which is a 
#  separate memory region
define space INTMEM type=ram_space size=1;

    # Register file
    #
    # The reason for modeling this in a RAM space is that @Ri, and other indexing
    #  operations can address these areas, which confuses the engine that assumes
    #  there is no other aliasing going on
    #
    # Technically these registers can also be remapped onto one of 4 banks, but
    #  this is not modeled at the moment.
    define INTMEM offset=0x00 size=1 [ R0 R1 R2 R3 R4 R5 R6 R7 ];
    define INTMEM offset=0x00 size=2 [ R0R1  R2R3  R4R5  R6R7  ];

# TODO: SFR is very sparsely populated, and is only direct addressable anyway..
#  perhaps this could be modeled with a separate constructor for direct addresses
#  into this area to catch illegal/extension writes?

# Special register space, sparsely populated RAM read/set by on-chip hardware
#
# Contents of this space are mapped in accordance of the datasheet, thus
#  the bottom 128 bytes are never used
define space SFR type=ram_space size=1;

    define SFR offset=0xE0 size=1 [ ACC ];
    define SFR offset=0xF0 size=1 [ B ];

    # PSW is Intentionally not mapped to the correct place, instead represented as a
    #  separate memory space `PSW_BITS`, where each bit is represented with a byte.
    #
    # The idea is so that this way CY access does not become a mess of shifting left
    #  and right in the decompiler view, and we can compensate for direct reads/writes
    #  to this SFR register via MOV specializations
    #
    # define SFR offset=0xD0 size=1 [ PSW ];

    define SFR offset=0x81 size=1 [ SP ];

    define SFR offset=0x82 size=2 [ DPTR ];
    define SFR offset=0x82 size=1 [ DPL DPH ];

define space PSW_BITS type=ram_space size=1;

    define PSW_BITS offset=0x0 size=1 [ P _ OV RS0 RS1 F0 AC CY ];

# External memory, 64k RAM
define space EXTMEM type=ram_space size=2;

define pcodeop nop;

# Context, meta instruction shenanigans
#
# While the processor itself has no context beside multi DPTR support (which is not modeled) some compilers
#  implement language intrinsics in a way that an intrinsic implementation function consumes its constexpr
#  parameters from the codespace by popping the return address, and reading data after it with `MOVC`
#
# This mixing of instructions and data in the same space confuses the disassembly engine, which expects
#  normal fallthrough semantics from the `LCALL`s to these functions, and tries to interpret their parameters
#  as instructions. Due to the almost complete utilization of the opbyte space, this usually does not trigger
#  an error until the code flow is completely destroyed, and dozens of phantom functions are created.
#
# All of this crazyness is compensated for with "meta LCALL instructions" - when an LCALL to a specific
#  address (which unfortunately varies by program to program) is encountered, we parse it as a meta instruction
#  which spans across multiple instructions, and implement the schemantics of the intrinsic in pcode.
#
# To make things even worse, some intrinsics consume a non constant (but defined in codespace) amount of
#  data after the LCALL to them. This case is compensated by changing the context into "meta instruction"
#  mode, and tracking the number of extra constructs to consume after the initial instruction in a 
#  context variable - essentially abusing the context register to implement a parsing state machine

# TODO: Compiler complains when I don't have a varnode attached, why?
define space CONTEXT type=ram_space size=1;
    
    define CONTEXT offset=0x0 size=8 [ contextreg ];

define context contextreg
    ctx_meta_op_mode       = (0, 0) noflow

    ctx_switch_arms_remain = (8,15) noflow
    ctx_switch_arms_max    = (16,31) noflow
;

#TOKENS

define token OpByteToken (8)
    oplo     = (0,3)
    ophi     = (4,7)
    rn       = (0,2)
    rnfill   = (3,3)
    ri       = (0,0)
    rifill   = (1,3)
;

define token ByteAddrToken1 (8)
    direct1  = (0,7)
    bank1    = (7,7)
    mainreg1 = (0,6)
;
define token ByteAddrToken2 (8)
    direct2  = (0,7)
    bank2    = (7,7)
    mainreg2 = (0,6)
;
define token WordAddrToken (16)
    addr16 = (0,15)
;

define token BitAddrToken (8)
    baddr_bit  = (0,2) dec
    baddr_byte = (3,7)
    baddr_bank = (7,7)

    baddr_psw = (0,2)
;

attach variables baddr_psw [ P _ OV RS0 RS1 F0 AC CY ];

define token RelativeOffsetToken (8)  
    rel8 = (0,7) signed
;
define token Data8 (8)  
    data8 = (0,7)
;
define token Data16 (16)
    data16 = (0,15)
;

define token aopword (16)
    aoplo     = (8,11)
    aopaddr   = (13,15)
    aaddrfill = (12,12)
    adata     = (0,7)
;

attach variables  rn [ R0 R1 R2 R3 R4 R5 R6 R7 ];
attach variables  ri [ R0 R1 ];

# flags macros

macro addflags(op1, op2) {
    CY = carry(op1,op2);
}

macro subflags(op1, op2) {
    CY = op1 < op2;
}

macro compflags(op1, op2) {
    CY = op1 < op2;
}

macro resultflags(op1) {
    # TODO
}

macro push8(val) {
    SP = SP + 1;
    *[INTMEM]:1 SP = val;
}
macro pop8(val) {
    val = *[INTMEM]:1 SP;
    SP = SP - 1;
}

macro push16(val) {
    al:1 = val:1;
    ah:1 = val(1);
  
    SP = SP + 1;
    *[INTMEM]:1 SP = al;
    SP = SP + 1; 
    *[INTMEM]:1 SP = ah;
}

macro pop16(val) {
    ah:1 = *[INTMEM]:1 SP;
    SP = SP - 1;
    al:1 = *[INTMEM]:1 SP;
    SP = SP - 1;
  
    val = (zext(ah) << 8) | zext(al);
}

# Operand display only
Ra:    "A"    is epsilon { export ACC;  }
Rc:    "CY"   is epsilon { export CY;   }
RDPTR: "DPTR" is epsilon { export DPTR; }

ADPTR:   "@A+"^DPTR is ophi & DPTR  { local addr:2 = zext(ACC) + DPTR; export addr; }
APC:     "@A+PC"    is ophi         { local addr:2 = zext(ACC) + inst_next; export addr; }

ATDPTR:  "@"^DPTR   is ophi & DPTR  { local addr:2 = DPTR; export *[EXTMEM]:1 addr; }

Rn:      rn        is rnfill=1 & rn { export rn; }
Ri:      @ri       is rifill=3 & ri { local addr:1 = ri;       export *[INTMEM]:1 addr; }
RiX:     @ri       is rifill=1 & ri { local addr:2 = zext(ri); export *[EXTMEM]:1 addr; }

Imm8:   "#"data8   is data8   { export *[const]:1 data8; }
Imm16:  "#"data16  is data16  { export *[const]:2 data16; }

Direct: mainreg1  is bank1=0 & mainreg1  { export *[INTMEM]:1 mainreg1; }
Direct: direct1   is bank1=1 & direct1   { export *[SFR]:1 direct1; }

Direct2: mainreg2  is bank2=0 & mainreg2 { export *[INTMEM]:1 mainreg2; }
Direct2: direct2   is bank2=1 & direct2  { export *[SFR]:1 direct2; }

AddrRel: addr is rel8            [ addr = inst_next + rel8; ]                            { export *:1 addr; }
Addr11:  addr is aopaddr & adata [ addr = (inst_next $and 0xf800)+(aopaddr*256)+adata; ] { export *:1 addr; }
Addr16:  addr is addr16          [ addr = addr16 + 0; ]                                  { export *:1 addr; }

with : baddr_byte != (0xD0 >> 3) {
    # Addr1M resolves to bit addresses which are meant to be 
    #  masked out of a real byte address

    Addr1MaskedRaw: addr is baddr_bank=0 & baddr_byte [ addr = baddr_byte + 0x20; ] {
        export *[INTMEM]:1 addr;
    }
    Addr1MaskedRaw: addr is baddr_bank=1 & baddr_byte [ addr = baddr_byte << 3; ] {
        export *[SFR]:1 addr;
    }

    # NB: This seemingly pointless layer of indirection is used because Ghidra does not
    #  like combinindg 'addr[baddr_bit]' in the patterns above, in this case references
    #  to external memory get replaced with the raw address literal
    Addr1M: Addr1MaskedRaw[baddr_bit] is Addr1MaskedRaw & baddr_bit {
        export Addr1MaskedRaw;
    }
}

with : baddr_byte = (0xD0 >> 3) {
    # Special "unmasked" mapping for PSW registers, which are spared from the
    #  bit banging normal Addr1M targets go through.
    #
    # This means that various bit addressing instructions will have two variants,
    #  one working on "masked" bits, one on registers representing 1 bit of data

    Addr1R: baddr_psw is baddr_psw {
        export baddr_psw;
    }
}

# Opcodes 

with : ctx_meta_op_mode = 0 {

:ACALL Addr11 is  aaddrfill=1 & aoplo=1 & Addr11 {
    local ret:2 = inst_next; push16(ret); call Addr11;
}

:ADD Ra,Rn      is ophi=2          & Ra & Rn     { addflags(ACC,Rn);     ACC = ACC + Rn;     resultflags(ACC); }
:ADD Ra,Direct  is ophi=2 & oplo=5 & Ra ; Direct { addflags(ACC,Direct); ACC = ACC + Direct; resultflags(ACC); }
:ADD Ra,Ri      is ophi=2          & Ra & Ri     { addflags(ACC,Ri);     ACC = ACC + Ri;     resultflags(ACC); }
:ADD Ra,Imm8    is ophi=2 & oplo=4 & Ra ; Imm8   { addflags(ACC,Imm8);   ACC = ACC + Imm8;   resultflags(ACC); }

:ADDC Ra,Rn     is ophi=3          & Ra & Rn     { local tmp:1 = CY + Rn;     addflags(ACC,tmp); ACC = ACC + tmp; resultflags(ACC); }
:ADDC Ra,Direct is ophi=3 & oplo=5 & Ra ; Direct { local tmp:1 = CY + Direct; addflags(ACC,tmp); ACC = ACC + tmp; resultflags(ACC); }
:ADDC Ra,Ri     is ophi=3          & Ra & Ri     { local tmp:1 = CY + Ri;     addflags(ACC,tmp); ACC = ACC + tmp; resultflags(ACC); }
:ADDC Ra,Imm8   is ophi=3 & oplo=4 & Ra ; Imm8   { local tmp:1 = CY + Imm8;   addflags(ACC,tmp); ACC = ACC + tmp; resultflags(ACC); }

:AJMP Addr11 is  aaddrfill=0 & aoplo=1 & Addr11 { goto Addr11; }

:ANL Ra,Rn     is ophi=5          & Ra & Rn      { ACC = ACC & Rn;     resultflags(ACC); }
:ANL Ra,Direct is ophi=5 & oplo=5 & Ra ; Direct  { ACC = ACC & Direct; resultflags(ACC); }
:ANL Ra,Ri     is ophi=5          & Ra & Ri      { ACC = ACC & Ri;     resultflags(ACC); }
:ANL Ra,Imm8   is ophi=5 & oplo=4 & Ra ; Imm8    { ACC = ACC & Imm8;   resultflags(ACC); }

:ANL Direct,Ra   is ophi=5 & oplo=2 & Ra; Direct  { Direct = Direct & ACC;  resultflags(Direct); }
:ANL Direct,Imm8 is ophi=5 & oplo=3; Direct; Imm8 { Direct = Direct & Imm8; resultflags(Direct); }

# C = C AND bit
:ANL Rc,Addr1M is ophi=8 & oplo=2 & Rc; Addr1M & baddr_bit {
    CY = CY & ((Addr1M >> baddr_bit) & 1); 
}
:ANL Rc,Addr1R is ophi=8 & oplo=2 & Rc; Addr1R {
    CY = CY & Addr1R;
}

# C = C AND NOT bit
:ANL Rc,!Addr1M is ophi=11 & oplo=0 & Rc; Addr1M & baddr_bit {
    CY = CY & !((Addr1M >> baddr_bit) & 1); 
}
:ANL Rc,!Addr1R is ophi=11 & oplo=0 & Rc; Addr1R {
    CY = CY & !Addr1R;
}

:CJNE Ra,Direct,AddrRel is ophi=11 & oplo=5 & Ra; Direct; AddrRel  { compflags(ACC,Direct); if (ACC!=Direct) goto AddrRel; }
:CJNE Ra,Imm8,AddrRel   is ophi=11 & oplo=4 & Ra; Imm8;   AddrRel  { compflags(ACC,Imm8);   if (ACC!=Imm8)   goto AddrRel; }
:CJNE Rn,Imm8,AddrRel   is ophi=11          & Rn; Imm8;   AddrRel  { compflags(Rn,Imm8);    if (Rn!=Imm8)    goto AddrRel; }
:CJNE Ri,Imm8,AddrRel   is ophi=11          & Ri; Imm8;   AddrRel  { compflags(Ri,Imm8);    if (Ri!=Imm8)    goto AddrRel; }

:CLR Ra is ophi=14 & oplo=4 & Ra  { ACC = 0; }
:CLR Rc is ophi=12 & oplo=3 & Rc  { CY = 0; }

:CLR Addr1M is ophi=12 & oplo=2; Addr1M & baddr_bit {
    Addr1M = Addr1M & ~(1 << baddr_bit); # bit = 0
}

:CPL Ra is ophi=15 & oplo=4 & Ra  { ACC = ~ACC;  }
:CPL Rc is ophi=11 & oplo=3 & Rc  { CY = CY ^ 1; }

# bit = NOT bit
:CPL Addr1M is ophi=11 & oplo=2; Addr1M & baddr_bit { 
    Addr1M = Addr1M ^ (1 << baddr_bit);
}
:CPL Addr1R is ophi=11 & oplo=2; Addr1R {
    Addr1R = !Addr1R; 
}

:DA Ra is ophi=13 & oplo=4 & Ra unimpl

:DEC Ra     is ophi=1 & oplo=4 & Ra      { ACC = ACC - 1; }
:DEC Rn     is ophi=1          & Rn      { Rn = Rn - 1; }
:DEC Direct is ophi=1 & oplo=5 ; Direct  { Direct = Direct - 1; }
:DEC Ri     is ophi=1          & Ri      { Ri = Ri - 1; }

# :DIV ABreg     is ophi=8 & oplo=4 & ABreg unimpl

:DJNZ Rn,AddrRel     is ophi=13 & rnfill=1 & Rn; AddrRel  { Rn = Rn - 1; if (Rn!=0) goto AddrRel; }
:DJNZ Direct,AddrRel is ophi=13 & oplo=5; Direct; AddrRel  { Direct = Direct - 1; if (Direct!=0) goto AddrRel; }

:INC Ra     is ophi=0 & oplo=4 & Ra      { ACC = ACC + 1; }
:INC Rn     is ophi=0          & Rn      { Rn = Rn + 1; }
:INC Direct is ophi=0 & oplo=5 ; Direct  { Direct = Direct + 1; }

:INC Ri      is ophi=0           & Ri    { Ri = Ri + 1; }
:INC RDPTR   is ophi=10 & oplo=3 & RDPTR { DPTR = DPTR + 1; }

# Jump if bit = 1
:JB Addr1M,AddrRel is ophi=2 & oplo=0; Addr1M & baddr_bit; AddrRel {
    local bit:1 = (Addr1M >> baddr_bit) & 1;

    if (bit) goto AddrRel;
}
:JB Addr1R,AddrRel is ophi=2 & oplo=0; Addr1R; AddrRel {
    if (Addr1R) goto AddrRel;
}

# Jump if bit = 1, clear bit
:JBC Addr1M,AddrRel is ophi=1 & oplo=0; Addr1M & baddr_bit; AddrRel {
    local bit:1 = (Addr1M >> baddr_bit) & 1;

    if (!bit) goto inst_next;

    Addr1M = Addr1M & ~(1 << baddr_bit);
    goto AddrRel;
}
:JBC Addr1R,AddrRel is ophi=1 & oplo=0; Addr1R; AddrRel {
    if (!Addr1R) goto inst_next;

    Addr1R = 0;
    goto AddrRel;
}

:JC  AddrRel is ophi=4 & oplo=0 ; AddrRel  { if (CY != 0) goto AddrRel; }
:JMP ADPTR   is ophi=7 & oplo=3 & ADPTR    { goto [ADPTR]; }

# Jump if bit = 0
:JNB Addr1M,AddrRel is ophi=3 & oplo=0; Addr1M & baddr_bit; AddrRel { 
    local bit:1 = (Addr1M >> baddr_bit) & 1;

    if (!bit) goto AddrRel;
}
:JNB Addr1R,AddrRel is ophi=3 & oplo=0; Addr1R; AddrRel { 
    if (!Addr1R) goto AddrRel;
}

:JNC AddrRel is ophi=5 & oplo=0; AddrRel  { if (CY  == 0) goto AddrRel; }
:JNZ AddrRel is ophi=7 & oplo=0; AddrRel  { if (ACC != 0) goto AddrRel; }
:JZ  AddrRel is ophi=6 & oplo=0; AddrRel  { if (ACC == 0) goto AddrRel; }

:LCALL Addr16 is ophi=1 & oplo=2; Addr16  {  ret:2 = inst_next; push16(ret); call Addr16; }
:LJMP  Addr16 is ophi=0 & oplo=2; Addr16  { goto Addr16; }

:MOV Ra,Rn          is ophi=14          & Ra & Rn          { ACC = Rn; }
:MOV Ra,Direct      is ophi=14 & oplo=5 & Ra; Direct       { ACC = Direct; }
:MOV Ra,Ri          is ophi=14          & Ra & Ri          { ACC = Ri; }
:MOV Ra,Imm8        is ophi=7  & oplo=4 & Ra; Imm8         { ACC = Imm8; }
:MOV Rn,Ra          is ophi=15          & Ra & Rn          { Rn = ACC; }
:MOV Rn,Direct      is ophi=10          & Rn; Direct       { Rn = Direct; }
:MOV Rn,Imm8        is ophi=7           & Rn; Imm8         { Rn = Imm8; }
:MOV Direct,Ra      is ophi=15 & oplo=5 & Ra; Direct       { Direct = ACC; }
:MOV Direct,Rn      is ophi=8           & Rn; Direct       { Direct = Rn; }
:MOV Direct2,Direct is ophi=8  & oplo=5 ; Direct; Direct2  { Direct2 = Direct; }
:MOV Direct,Ri      is ophi=8           & Ri; Direct       { Direct = Ri; }
:MOV Direct,Imm8    is ophi=7  & oplo=5 ; Direct; Imm8     { Direct = Imm8; }
:MOV Ri,Ra          is ophi=15          & Ra & Ri          { Ri = ACC; }
:MOV Ri,Direct      is ophi=10          & Ri; Direct       { Ri = Direct; }
:MOV Ri,Imm8        is ophi=7           & Ri; Imm8         { Ri = Imm8; }
:MOV RDPTR,Imm16    is ophi=9  & oplo=0 & RDPTR; Imm16     { DPTR = Imm16; }

:MOV Rc,Addr1M is ophi=10 & oplo=2 & Rc; Addr1M & baddr_bit {
    CY = (Addr1M >> baddr_bit) & 1;
}
:MOV Rc,Addr1R is ophi=10 & oplo=2 & Rc; Addr1R {
    CY = Addr1R;
}

:MOV Addr1M,Rc is ophi=9 & oplo=2 & Rc; Addr1M & baddr_bit {
    Addr1M = Addr1M & ~(1 << baddr_bit) | (CY << baddr_bit);
}
:MOV Addr1R,Rc is ophi=9 & oplo=2 & Rc; Addr1R {
    Addr1R = CY;
}

:MOVC Ra,ADPTR is ophi=9 & oplo=3 & Ra & ADPTR  { ACC = *:1 ADPTR; }
:MOVC Ra,APC   is ophi=8 & oplo=3 & Ra & APC    { ACC = *:1 APC; }

:MOVX Ra,RiX    is ophi=14          & Ra & RiX     { ACC = RiX; }
:MOVX Ra,ATDPTR is ophi=14 & oplo=0 & Ra & ATDPTR  { ACC = ATDPTR; }
:MOVX RiX,Ra    is ophi=15          & Ra & RiX     { RiX = ACC; }
:MOVX ATDPTR,Ra is ophi=15 & oplo=0 & Ra & ATDPTR  { ATDPTR = ACC; }

#:MUL ABreg         is ophi=10 & oplo=4 & ABreg     { PSW = PSW & 0x7b; tmp:2 = zext(ACC) * zext(B); ACC = tmp(0); B = tmp(1); PSW = PSW | ((B!=0)<<2); }

:NOP is ophi=0  & oplo=0  { nop(); }

:ORL Ra,Rn       is ophi=4          & Ra & Rn       { ACC = ACC | Rn; }
:ORL Ra,Direct   is ophi=4 & oplo=5 & Ra ; Direct   { ACC = ACC | Direct; }
:ORL Ra,Ri       is ophi=4          & Ra & Ri       { ACC = ACC | Ri; }
:ORL Ra,Imm8     is ophi=4 & oplo=4 & Ra ; Imm8     { ACC = ACC | Imm8; }
:ORL Direct,Ra   is ophi=4 & oplo=2 & Ra ; Direct   { Direct = Direct | ACC; }
:ORL Direct,Imm8 is ophi=4 & oplo=3 ; Direct; Imm8  { Direct = Direct | Imm8; }

# C = C OR bit
:ORL Rc,Addr1M is ophi=7 & oplo=2 & Rc; Addr1M & baddr_bit {
    CY = CY | ((Addr1M >> baddr_bit) & 1);
}
:ORL Rc,Addr1R is ophi=7 & oplo=2 & Rc; Addr1R {
    CY = CY | Addr1R;
}

# C = C OR NOT bit
:ORL Rc,Addr1M is ophi=10 & oplo=0 & Rc; Addr1M & baddr_bit {
    CY = CY | !((Addr1M >> baddr_bit) & 1);
}
:ORL Rc,Addr1R is ophi=10 & oplo=0 & Rc; Addr1R {
    CY = CY | !Addr1R;
}

:POP  Direct is ophi=13 & oplo=0; Direct  { pop8(Direct); }

:PUSH Direct is ophi=12 & oplo=0; Direct  { push8(Direct); }

:RET  is ophi=2 & oplo=2  { pc:2 = 0; pop16(pc); return[pc]; }
:RETI is ophi=3 & oplo=2  { pc:2 = 0; pop16(pc); return[pc]; }

:RL   Ra is ophi=2 & oplo=3 & Ra  { ACC = (ACC << 1) | (ACC >> 7); }
:RR   Ra is ophi=0 & oplo=3 & Ra  { ACC = (ACC >> 1) | (ACC << 7); }

:RLC  Ra is ophi=3 & oplo=3 & Ra  { local tmp:1 = (ACC & 0x80) >> 7; ACC = (ACC<<1) | CY; CY = tmp; }
:RRC  Ra is ophi=1 & oplo=3 & Ra  { local tmp:1 = (ACC & 1); ACC = (ACC >> 1) | (CY << 7); CY = tmp; }

:SETB  CY is CY & ophi=13 & oplo=3  { CY = 1; }

# bit = 1
:SETB Addr1M is ophi=13 & oplo=2; Addr1M & baddr_bit {
    Addr1M = Addr1M | (1 << baddr_bit);
}
:SETB Addr1R is ophi=13 & oplo=2; Addr1R {
    Addr1R = 1;
}

:SJMP AddrRel        is ophi=8 & oplo=0; AddrRel  { goto AddrRel; }

:SUBB Ra,Rn     is ophi=9          & Ra & Rn      { local tmp:1 = CY + Rn;     subflags(ACC,tmp); ACC = ACC - tmp; }
:SUBB Ra,Direct is ophi=9 & oplo=5 & Ra ; Direct  { local tmp:1 = CY + Direct; subflags(ACC,tmp); ACC = ACC - tmp; }
:SUBB Ra,Ri     is ophi=9          & Ra & Ri      { local tmp:1 = CY + Ri;     subflags(ACC,tmp); ACC = ACC - tmp; }
:SUBB Ra,Imm8   is ophi=9 & oplo=4 & Ra ; Imm8    { local tmp:1 = CY + Imm8;   subflags(ACC,tmp); ACC = ACC - tmp; }

:SWAP Ra       is ophi=12 & oplo=4 & Ra  { ACC = (ACC>>4) | (ACC<<4); }

:XCH Ra,Rn     is ophi=12          & Ra & Rn     { local tmp:1 = ACC; ACC = Rn;     Rn = tmp; }
:XCH Ra,Direct is ophi=12 & oplo=5 & Ra ; Direct { local tmp:1 = ACC; ACC = Direct; Direct = tmp; }
:XCH Ra,Ri     is ophi=12          & Ra & Ri     { local tmp:1 = ACC; ACC = Ri;     Ri = tmp; }

:XCHD Ra,Ri    is ophi=13 & Ra & Ri  { local tmp:1 = ACC & 0xf; ACC = (ACC&0xf0) | (Ri&0xf); Ri = (Ri&0xf0) | tmp; }

:XRL Ra,Rn       is ophi=6          & Ra & Rn      { ACC = ACC ^ Rn; }
:XRL Ra,Direct   is ophi=6 & oplo=5 & Ra ; Direct  { ACC = ACC ^ Direct; }
:XRL Ra,Ri       is ophi=6          & Ra & Ri      { ACC = ACC ^ Ri; }
:XRL Ra,Imm8     is ophi=6 & oplo=4 & Ra ; Imm8    { ACC = ACC ^ Imm8; }
:XRL Direct,Ra   is ophi=6 & oplo=2 & Ra ; Direct  { Direct = Direct ^ ACC; }
:XRL Direct,Imm8 is ophi=6 & oplo=3 ; Direct; Imm8 { Direct = Direct ^ Imm8; }

}

@if 0

define token mb_0t (8) mb0_rn = (0,2) mb0_rnfill = (3,3) mb0_oplo = (0,3) mb0_ophi = (4,7);
define token mb_1t (8) mb1_rn = (0,2) mb1_rnfill = (3,3) mb1_oplo = (0,3) mb1_ophi = (4,7);
define token mb_2t (8) mb2_rn = (0,2) mb2_rnfill = (3,3) mb2_oplo = (0,3) mb2_ophi = (4,7);
define token mb_3t (8) mb3_rn = (0,2) mb3_rnfill = (3,3) mb3_oplo = (0,3) mb3_ophi = (4,7);
define token mb_4t (8) mb4_rn = (0,2) mb4_rnfill = (3,3) mb4_oplo = (0,3) mb4_ophi = (4,7);
define token mb_5t (8) mb5_rn = (0,2) mb5_rnfill = (3,3) mb5_oplo = (0,3) mb5_ophi = (4,7);
define token mb_6t (8) mb6_rn = (0,2) mb6_rnfill = (3,3) mb6_oplo = (0,3) mb6_ophi = (4,7);
define token mb_7t (8) mb7_rn = (0,2) mb7_rnfill = (3,3) mb7_oplo = (0,3) mb7_ophi = (4,7);

# === Pseudo instructions: Wide register arithmetic ====================

with : ctx_meta_op_mode = 0 {
    # TODO: CPU flags not modeled

    :__add16 is
        mb0_ophi=14 & mb0_rnfill=1 & mb0_rn=3; # MOV  A,R3
        mb1_ophi=2  & mb1_rnfill=1 & mb1_rn=5; # ADD  A,R5
        mb2_ophi=15 & mb2_rnfill=1 & mb2_rn=3; # MOV  R3,A
        mb3_ophi=14 & mb3_rnfill=1 & mb3_rn=2; # MOV  A,R2
        mb4_ophi=3  & mb4_rnfill=1 & mb4_rn=4; # ADDC A,R4
        mb5_ophi=15 & mb5_rnfill=1 & mb5_rn=2  # MOV  R2,A
    {
        local c:1 = carry(R3, R5);

        R3 = R3 + R5;
        R2 = R2 + R4 + c;
    }

    :__sub16 is
        mb0_ophi=14 & mb0_rnfill=1 & mb0_rn=5; # MOV  A,R5
        mb1_ophi=12 & mb1_oplo=3;              # CLR  CY
        mb2_ophi=9  & mb2_rnfill=1 & mb2_rn=3; # SUBB A,R3
        mb3_ophi=15 & mb3_rnfill=1 & mb3_rn=3; # MOV  R3,A
        mb4_ophi=14 & mb4_rnfill=1 & mb4_rn=4; # MOV  A,R4
        mb5_ophi=9  & mb5_rnfill=1 & mb5_rn=2; # SUBB A,R2
        mb6_ophi=15 & mb6_rnfill=1 & mb6_rn=2; # MOV  R2,A

        # mb7_ophi=4  & mb7_rnfill=1 & mb7_rn=3  # ORL  A,R3
        epsilon
    {
        local b:1 = sborrow(R5, R3);

        R3 = R5 - R3;
        R2 = R4 - R2 - b;
    }

    :__sub16 is
        mb0_ophi=12 & mb0_oplo=3;              # CLR  CY
        mb1_ophi=14 & mb1_rnfill=1 & mb1_rn=5; # MOV  A,R5
        mb2_ophi=9  & mb2_rnfill=1 & mb2_rn=3; # SUBB A,R3
        mb3_ophi=15 & mb3_rnfill=1 & mb3_rn=3; # MOV  R3,A
        mb4_ophi=14 & mb4_rnfill=1 & mb4_rn=4; # MOV  A,R4
        mb5_ophi=9  & mb5_rnfill=1 & mb5_rn=2; # SUBB A,R2
        mb6_ophi=15 & mb6_rnfill=1 & mb6_rn=2; # MOV  R2,A
        
        # mb7_ophi=4  & mb7_rnfill=1 & mb7_rn=3  # ORL  A,R3
        epsilon
    {
        local b:1 = sborrow(R5, R3);

        R3 = R5 - R3;
        R2 = R4 - R2 - b;
    }
}

# ==== Pseudo instructions: __ccopy ====================

define token ccopy_data (48)
    ccopy_dst = (0,15)
    ccopy_src = (16,31) 
    ccopy_end = (32,47)
;

with : ctx_meta_op_mode = 0 {
    :__ccopy ccopy_src-len->ccopy_dst is ophi=1 & oplo=2; addr16=0x0e2c; ccopy_src & ccopy_end & ccopy_dst [ len = ccopy_end - ccopy_src; ] {
        src:2 = ccopy_src;
        dst:2 = ccopy_dst;

        <loop>
        *[EXTMEM]:1 dst = *[CODE]:1 src;
        src = src + 1;
        dst = dst + 1;
        if (src != ccopy_end) goto <loop>;
    }
}

# ==== Pseudo instructions: __operator++/-- ====================

define token inc_width_t (8) inc_width = (0,7); 

with : ctx_meta_op_mode = 0 {
    # Main operator - not actually directly used, thus not lifted
    :__operator+= is ophi=1 & oplo=2; addr16=0x0c06; inc_width unimpl

    # Default cases for non-implemented widths
    :__operator++ is ophi=1 & oplo=2; addr16=0x0bfc; inc_width unimpl
    :__operator-- is ophi=1 & oplo=2; addr16=0x0c02; inc_width unimpl

    # Implementations
    :__operator++ is ophi=1 & oplo=2; addr16=0x0bfc; inc_width=1 {
        local addr:2 = R2R3;
        local v:1 = (*[EXTMEM]:1 addr);
        *[EXTMEM]:1 addr = v;
        R3 = v;
    }
    :__operator-- is ophi=1 & oplo=2; addr16=0x0c02; inc_width=1 {
        local addr:2 = R2R3;
        local v:1 = (*[EXTMEM]:1 addr);
        *[EXTMEM]:1 addr = v - 1;
        R3 = v;
    }

    :__operator++ is ophi=1 & oplo=2; addr16=0x0bfc; inc_width=2 {
        local addr:2 = R2R3;
        local v:2 = (*[EXTMEM]:2 addr);
        *[EXTMEM]:2 addr = v + 1;
        R2R3 = v;
    }
    :__operator-- is ophi=1 & oplo=2; addr16=0x0c02; inc_width=2 {
        local addr:2 = R2R3;
        local v:2 = (*[EXTMEM]:2 addr);
        *[EXTMEM]:2 addr = v - 1;
        R2R3 = v;
    }
}

# ==== Pseudo instructions: switch range =====================

define token sw_min_t (16) sw_min = (0,15);
define token sw_max_t (16) sw_max = (0,15);
define token sw_default_t (16) sw_default = (0,15);

SwDefault: is sw_default { export *:1 sw_default; }

with : ctx_meta_op_mode = 0 {
    :__switch sw_min,sw_max is ophi=1 & oplo=2; addr16=0x0d6c; sw_min; sw_max; SwDefault
    [
        # Enter meta parsing mode
        ctx_meta_op_mode = 1;
        globalset(inst_next, ctx_meta_op_mode);

        # Propagate active switch info
        ctx_switch_arms_max = sw_max;
        globalset(inst_next, ctx_switch_arms_max);

        # Expect some switch arms to follow
        ctx_switch_arms_remain = sw_max - sw_min + 1;
        globalset(inst_next, ctx_switch_arms_remain);
    ]
    {
        if (R2R3 < sw_min) goto SwDefault;
        if (R2R3 > sw_max) goto SwDefault;

        local case:2 = inst_next + (R2R3 - sw_min) * 2;
        local target:2 = *[CODE]:2 case;
        goto [target];
    }
}

with : ctx_meta_op_mode = 1 {
    # Below constructors are intended to automatically consume jumptable
    #  following a __switch

    :__switch_case sw_case Addr16 is ctx_switch_arms_remain != 1 & Addr16
    [
        sw_case = ctx_switch_arms_max - ctx_switch_arms_remain;

        # Propagate context
        globalset(inst_next, ctx_meta_op_mode);
        globalset(inst_next, ctx_switch_arms_max);

        # Expect more switch arms
        ctx_switch_arms_remain = ctx_switch_arms_remain - 1;
        globalset(inst_next, ctx_switch_arms_remain);
    ]
    {}

    :__switch_case sw_case Addr16 is ctx_switch_arms_remain = 1 & Addr16
    [
        sw_case = ctx_switch_arms_max;

        # Exit meta parsing mode
        ctx_meta_op_mode = 0;
        globalset(inst_next, ctx_meta_op_mode);
    ]
    {}
}

# ==== Pseudo instructions: unknown =====================

define token code_param_t8  (8)  code_param8  = (0,1);
define token code_param_t16 (16) code_param16 = (0,1);
define token code_param_t24 (24) code_param24 = (0,1);
define token code_param_t32 (32) code_param32 = (0,1);

with : ctx_meta_op_mode = 0 {

    # Weird LJMP specialization - function pointer support?
    :__unkD Addr16 ??? is ophi=0 & oplo=2; addr16=0x0ea0 & Addr16 {
        call Addr16;

        local base:2 = R6R7;

        local target:2 = *[EXTMEM]:2 base;
        R6R7 = *[EXTMEM]:2 (base + 2);

        goto [target];
    }

}

@endif
